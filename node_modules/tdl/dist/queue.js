"use strict";
// The queue implementation is taken from Node.js
// https://github.com/nodejs/node/blob/bae03c4e30f927676203f61ff5a34fe0a0c0bbc9/lib/internal/fixed_queue.js
// The authors are Node.js contributors, MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Queue = void 0;
const kSize = 2048;
const kMask = kSize - 1;
class FixedCircularBuffer {
    constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
    }
    isEmpty() {
        return this.top === this.bottom;
    }
    isFull() {
        return ((this.top + 1) & kMask) === this.bottom;
    }
    push(data) {
        this.list[this.top] = data;
        this.top = (this.top + 1) & kMask;
    }
    shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === undefined)
            return null;
        this.list[this.bottom] = undefined;
        this.bottom = (this.bottom + 1) & kMask;
        return nextItem;
    }
}
class Queue {
    constructor() {
        this.head = this.tail = new FixedCircularBuffer();
    }
    isEmpty() {
        return this.head.isEmpty();
    }
    push(data) {
        if (this.head.isFull()) {
            // Head is full: Creates a new queue, sets the old queue's `.next` to it,
            // and sets it as the new main queue.
            this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
    }
    shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
            // If there is another queue, it forms the new tail.
            this.tail = tail.next;
            tail.next = null;
        }
        return next;
    }
}
exports.Queue = Queue;
